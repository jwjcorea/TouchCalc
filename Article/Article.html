<p style="text-align: left;"><img src="/image.axd?picture=2010%2f8%2fTouchCalc2.jpg" alt="" width="332" height="229" /></p>
<h2 style="text-align: left;">Introduction<br /></h2>
<p style="text-align: left;">I have been designing and developing mobile applications for less than 1 year, though I'm a professional software developer for 10 years or so, and this new mobile era makes me feel excited. As of today there are two and a half major platforms gaining pretty well reputation by the mobile users. Two of them are iOS (formerly known as iPhone OS) and Android and the half is long debated Windows Phone 7.</p>
<p style="text-align: left;">In this tutorial article I will try to introduce you to the general development principles of Android by building a real calculator application (TouchCalculator). By the end of this tutorial you will be able to build Android applications with simple user interfaces and backing business logic.</p>
<h2 style="text-align: left;">Preparing Yourself and The Development Environment</h2>
<p style="text-align: left;">Before you get started, if you are totally new to Android I would suggest you to read the <a href="http://developer.android.com/guide/basics/what-is-android.html" target="_blank">What is Android?</a> section from the Android Developers site and I would also suggest you to have a look at <a href="http://android-developers.blogspot.com/2010/05/android-22-and-developers-goodies.html" target="_blank">Android Developers Blog</a>.</p>
<p style="text-align: left;">If you have not configured an Android development environment already, please follow the instructions in this <a href="http://developer.android.com/sdk/index.html" target="_blank">link</a>.</p>
<h2 style="text-align: left;">TouchCalculator MockUp<br /></h2>
<p style="text-align: left;">TouchCalculator, our sample and simple calculator, is a standard calculator supporting four arithmetic operations and three mathematical functions (namely square root, reciprocle and percentage) along with a memory buffer.</p>
<p style="text-align: left;">Let's start with the mockup of our calculator. Below is a color coded sketch of our application. I've seperated the UI into locigal parts and each part is represented with a color highlight. There is a reasoning behind the conceptual seperation and this will be evident in the next sections of the tutorial.</p>
<p style="text-align: left;"><img src="/image.axd?picture=2010%2f8%2ftcMockup.png" alt="" width="298" height="318" /></p>
<p style="text-align: left;">So, let us see what is intended with each region in our mockup.</p>
<ol>
<li>We will display the subsequent user input until user presses (=) to calculate the result or C to clear the input buffer</li>
<li>Immediate user input and the result of the buffer will be displayed</li>
<li>Memory buffer value will be displayed in this area</li>
<li>Memory buffer operation buttons</li>
<li>Other operation buttons</li>
<li>Calculate button</li>
<li>Arithmetic operation buttons</li>
<li>Numeric keypad buttons</li>
<li>Immediate input and buffer clear buttons</li>
</ol>
<h2 style="text-align: left;">TouchCalculator Use Cases <br /></h2>
<p style="text-align: left;">Our calculator shall be able to support the following use cases</p>
<ul>
<li>Calculator shall be initialized with input value of 0 and as soon as the user starts pressing numeric keypad buttons, input capture shall start</li>
<li>User will press the numeric keypad buttons and we will append each numeric value to the current value of Area #2</li>
<li>If user presses the decimal seperator button placed in Area #5 we shall append the seperator to the current value of Area #2</li>
<li>When user presses an arithmetic operator button placed in Area #7 we shall display the input buffer content in Area #1. If input buffer has enough input to produce a result we shall also calculate the result and display the value in Area #2</li>
<li>When user presses (=) button and if input buffer has enough input to produce a result we shall calculate the result and display it in Area #2, else do nothing. </li>
<li>When user presses the backspace button (&lt;-) we shall trim the last digit of the value displayed in Area #2</li>
<li>When the user presses the CE button we shall reset the value displayed in Area #2 so that it becomes 0</li>
<li>When user presses the C button we shall reset the input buffer and the value displayed in Area #2 so that it becomes 0</li>
<li>When user presses (&plusmn;) we shall toggle the sign of the user input value displayed in Area #2</li>
<li>When user presses MC button we shall clear the memory buffer</li>
<li>When user presses MR button we shall read the value in memory buffer and display that value in Area #2</li>
<li>When user presses MS button we shall set the value of the memory buffer to the value displayed in Area #2</li>
<li>When user presses M+ or M- buttons we shall add/subtract the value displayed in Area #2 with the exisiting value of the memory buffer</li>
<li>When user presses SQRT button we shall calculate the square root of the value displayed in Area #2 and display the result in Area #2 </li>
<li>When user presses 1/x button we shall calculate the reciprocle of the  value displayed in Area #2 and display the result in Area #</li>
<li>When user presses % button we shall calculate the result of the input buffer and find the percent of the result and display in Area #2 </li>
</ul>
<p>&nbsp;</p>
<h2>Creating The Bare Bones User Interface</h2>
<p style="text-align: left;">Since we have our calculator mockup, we can start creating the bare bones Android user interface of our calculator. When you create a new Android project in Eclipse, you will have a default layout xml file named main.xml under res/layout folder. We will create the bare bones calculator user interface declaratively, not from code, inside this xml file. Using declarative xml files, layout files, while constructing the user interface has advantages. The primary advantage of using XML is that you seperate the presentation of your application from the code used to control your applications behaviour. In a team environment this seperation enables designers and coders to work on the same application simultaneously. Designers familiar with HTML can easly design Android user interfaces once they get familiar with Android layout vocabulary.You can read more about Android layouts from <a href="http://developer.android.com/guide/topics/ui/declaring-layout.html" target="_blank">here</a>.</p>
<p style="text-align: left;">Now, lets see how we can accomplish an Android UI to represent different UI parts sketched in our TouchCalculator Mockup. Building blocks of Android UI are <a href="http://developer.android.com/reference/android/view/package-summary.html" target="_blank">Views</a> and <a href="http://d.android.com/reference/android/view/ViewGroup.html" target="_blank">ViewGroups</a>. Views are basic user interface bits which provide screen layout and user interaction. For example Button, TextView and CheckBox are simple views extending the abstract View class. ViewGroups are composite user interface bits which can contain multiple Views and other ViewGroups. LinearLayout and GridView are two of the view groups we will use to construct our calculator.</p>
<p style="text-align: left;">In our mockup, we have actually four sections layed out in linear direction vertically. First three sections are for the areas labeled with 1,2 and 3 and the fourth section is for the keypad, containing sections labeled with 4,5,6,7,8 and 9. Thus, we will use LinearLayout ViewGroup so that we can place Views for each section. Here is our bare bones layout XML</p>
<pre class="brush:xml;"><br /><br />&lt;?xml version="1.0" encoding="utf-8"?&gt;<br />&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"<br />    android:orientation="vertical"<br />    android:layout_width="fill_parent"<br />    android:layout_height="fill_parent"&gt;<br />	<br />	&lt;TextView  <br />	    android:id="@+id/txtStack"<br />	    android:layout_width="fill_parent" <br />	    android:layout_height="wrap_content" <br />	   	android:textSize="15sp"<br />	    android:gravity="right"<br />	    android:layout_marginTop = "3sp"<br />	    android:layout_marginLeft = "5sp"<br />	    android:layout_marginRight = "5sp"/&gt;<br />   <br /><br />    &lt;TextView  <br />    	android:id="@+id/txtInput"<br />    	android:layout_width="fill_parent" <br />    	android:layout_height="wrap_content" <br />    	android:textSize="25sp"<br />    	android:gravity="right"<br />    	android:layout_marginLeft = "5sp"<br />   		android:layout_marginRight = "5sp"/&gt;<br /><br /><br />    &lt;TextView  <br />    	android:id="@+id/txtMemory"<br />    	android:layout_width="fill_parent" <br />    	android:layout_height="wrap_content" <br />    	android:textSize="15sp"<br />    	android:gravity="left"<br />        android:layout_marginLeft = "5sp"<br />   		android:layout_marginRight = "5sp"/&gt;<br />   		<br />&lt;GridView xmlns:android="http://schemas.android.com/apk/res/android" <br />    android:id="@+id/grdButtons"<br />    android:layout_width="fill_parent" <br />    android:layout_height="fill_parent"<br />    android:columnWidth="90dp"<br />    android:numColumns="5"<br />    android:verticalSpacing="10dp"<br />    android:horizontalSpacing="10dp"<br />    android:stretchMode="columnWidth"<br />    android:gravity="center"/&gt;<br />&lt;/LinearLayout&gt;</pre>
<p style="text-align: left;">We will use <a href="http://developer.android.com/reference/android/widget/TextView.html" target="_blank">TextView </a> to represent areas labeled with 1,2 and 3 in our mockup. We will use <a href="http://developer.android.com/reference/android/widget/GridView.html" target="_blank">GridView</a> ViewGroup for the keypad. We will place our keypad buttons inside the cells of the GridView at runtime by using an <a href="http://developer.android.com/reference/android/widget/Adapter.html" target="_blank">Adapter</a>.</p>
<p style="text-align: left;">Most of the View and ViewGroup attributes are self explanatory. You can infer easily what an attribute is used for, actually Eclipse xml editor will also help you if you press Ctrl+Space you will be presented a list of attributes. I will mention <strong>id</strong> attribute explicitly since it has special importance. Any view or view group can have an <strong>id</strong> attribute, but this is not a must. If you want to get reference to the View or ViewGroup from your code, you should set the id attribute of your Views and ViewGroups. id attribute has some sort of special notation which you can read more about <a href="http://developer.android.com/guide/topics/ui/declaring-layout.html#id" target="_blank">here</a>.</p>
<p style="text-align: left;">If you press on the Layout tab in Eclipse&nbsp; XML editor where our layout is defined, you will see the bare bones UI as shown in the image below. Note that by using the LinearLayout we have managed to put each logial section in linear direction vertically.</p>
<p><img src="/image.axd?picture=2010%2f8%2fbareBones.PNG" alt="" width="216" height="289" /></p>
<h2><br /></h2>
<h2>Loading And Displaying The Layout<br /></h2>
<p style="text-align: left;">The XML layout we have defined is not enough by itself, since the users can not get into interaction with our application through the layout directly. As the terminology implies layout XML is used just for defining the placement and visual aspects of the UI bits. What we need in order to enable user interaction is the <a href="http://developer.android.com/reference/android/app/Activity.html" target="_blank">Activity</a> class, which controls the behaviour of our UI and enables user interaction.</p>
<p style="text-align: left;">When you create a new Android project with Eclipse, you will be asked for the details of your project and one of them is the optional Create Activity check box along with a name for your first Android activity class. For all practical purposes we have named our activity to be <strong>main</strong>. Eclipse will automatically create a "main.java" file under the src/package node. Here is the initial contents of our main activity class</p>
<pre class="brush:java;">package com.pragmatouch.calculator;<br /><br />import android.app.Activity;<br />import android.os.Bundle;<br /><br />public class main extends Activity {<br /><br />	/** Called when the activity is first created. */<br />	@Override<br />	public void onCreate(Bundle savedInstanceState) {<br />		super.onCreate(savedInstanceState);<br />		setContentView(R.layout.main);<br /><br />	}<br />}</pre>
<p style="text-align: left;">As you can see, we override the <strong>onCreate </strong>(Line 10) method of the base Activity and perform activity initialization, loading layout is part of our initialization process, inside the overriden method.</p>
<p style="text-align: left;"><strong>setContentView</strong> method called on Line 12 belongs to base <strong>Activity</strong> class and is used to load the UI layout from a resource (main.xml) identified by an integer. Please note how we get the integer identifier of our main.xml. When Android builds your application, it automatically generates a class named R (can be found under /TouchCalculator/gen/com/pragmatouch/calculator/R.java) and generates identifier constants for your resources, since main.xml is a resource Android generates a constant for us and we can use that constant from our code to load our layout.</p>
<p style="text-align: left;">If you run the application you will see an empty UI with two linear TextViews placed on top with no keypad.</p>
<h2 style="text-align: left;">Modeling The Keypad Buttons</h2>
<p style="text-align: left;">In this section, we will model our keypad buttons using <a href="http://download.oracle.com/javase/tutorial/java/javaOO/enum.html" target="_blank">Java enum type</a>. Java enums are interesting for a guy like me. Spending too many years with C# I must confess that Java enums are much more capable than the C# enums since the Java enum class body can include methods  and other fields.&nbsp;</p>
<p style="text-align: left;">To model the keypad buttons we will declare a KeypadButton enum class, which will also hold button text and category information.</p>
<pre class="brush:java;">package com.pragmatouch.calculator;<br /><br />public enum KeypadButton {<br />  MC("MC",KeypadButtonCategory.MEMORYBUFFER)<br />, MR("MR",KeypadButtonCategory.MEMORYBUFFER)<br />, MS("MS",KeypadButtonCategory.MEMORYBUFFER)<br />, M_ADD("M+",KeypadButtonCategory.MEMORYBUFFER)<br />, M_REMOVE("M-",KeypadButtonCategory.MEMORYBUFFER)<br />, BACKSPACE("&lt;-",KeypadButtonCategory.CLEAR)<br />, CE("CE",KeypadButtonCategory.CLEAR)<br />, C("C",KeypadButtonCategory.CLEAR)<br />, ZERO("0",KeypadButtonCategory.NUMBER)<br />, ONE("1",KeypadButtonCategory.NUMBER)<br />, TWO("2",KeypadButtonCategory.NUMBER)<br />, THREE("3",KeypadButtonCategory.NUMBER)<br />, FOUR("4",KeypadButtonCategory.NUMBER)<br />, FIVE("5",KeypadButtonCategory.NUMBER)<br />, SIX("6",KeypadButtonCategory.NUMBER)<br />, SEVEN("7",KeypadButtonCategory.NUMBER)<br />, EIGHT("8",KeypadButtonCategory.NUMBER)<br />, NINE("9",KeypadButtonCategory.NUMBER)<br />, PLUS(" + ",KeypadButtonCategory.OPERATOR)<br />, MINUS(" - ",KeypadButtonCategory.OPERATOR)<br />, MULTIPLY(" * ",KeypadButtonCategory.OPERATOR)<br />, DIV(" / ",KeypadButtonCategory.OPERATOR)<br />, RECIPROC("1/x",KeypadButtonCategory.OTHER)<br />, DECIMAL_SEP(",",KeypadButtonCategory.OTHER)<br />, SIGN("&plusmn;",KeypadButtonCategory.OTHER)<br />, SQRT("SQRT",KeypadButtonCategory.OTHER)<br />, PERCENT("%",KeypadButtonCategory.OTHER)<br />, CALCULATE("=",KeypadButtonCategory.RESULT)<br />, DUMMY("",KeypadButtonCategory.DUMMY);<br /><br /> CharSequence mText; // Display Text<br /> KeypadButtonCategory mCategory;<br />	<br />  KeypadButton(CharSequence text,KeypadButtonCategory category) {<br />    mText = text;<br />    mCategory = category;<br />  }<br /><br />  public CharSequence getText() {<br />    return mText;<br />  }<br />}<br /></pre>
<p style="text-align: left;">Each keypad button shown in our mockup is represented with an enum constant and each constant also holds a text and a category value. We also use Java enums to represent the keypad button categories and declare a KeypadButtonCategory enum class.</p>
<pre class="brush:java;">package com.pragmatouch.calculator;<br /><br />public enum KeypadButtonCategory {<br />  MEMORYBUFFER<br />  , NUMBER<br />  , OPERATOR<br />  , DUMMY<br />  , CLEAR<br />  , RESULT<br />  , OTHER<br />}<br /><br /></pre>
<p style="text-align: left;">We will utilize KeypadButtonCategory enums for applying different styles for each category so that our sample calculator seems more colorfull.</p>
<h2 style="text-align: left;">Creating The Keypad Buttons</h2>
<p style="text-align: left;">As I mentioned in the previous sections, we will use GridView to display our keypad. We will use a five column GridView and we will declare an <a href="http://developer.android.com/reference/android/widget/Adapter.html" target="_blank">Adapter<br /></a>which extends the BaseAdapter class and is responsible of providing data to our AdapterView that is a GridView in our case.</p>
<pre class="brush:java;"><br />package com.pragmatouch.calculator;<br /><br />import android.widget.*;<br />import android.content.*;<br />import android.view.*;<br />import android.view.View.OnClickListener;<br /><br />public class KeypadAdapter extends BaseAdapter {<br />  private Context mContext;<br />	<br />  public KeypadAdapter(Context c) {<br />    mContext = c;<br />  }<br /><br />  public int getCount() {<br />    return mButtons.length;<br />  }<br /><br />  public Object getItem(int position) {<br />    return mButtons[position];<br />  }<br /><br />  public long getItemId(int position) {<br />    return 0;<br />  }<br /><br />// create a new ButtonView for each item referenced by the Adapter<br />public View getView(int position, View convertView, ViewGroup parent) {<br />  Button btn;<br />  if (convertView == null) { // if it's not recycled, initialize some attributes<br />    btn = new Button(mContext);<br />    KeypadButton keypadButton = mButtons[position];<br />						<br />    // Set CalculatorButton enumeration as tag of the button so that we<br />    // will use this information from our main view to identify what to do<br />    btn.setTag(keypadButton);<br />  } <br />  else {<br />    btn = (Button) convertView;<br />  }<br /><br />  btn.setText(mButtons[position].getText());<br />  return btn;<br />}<br /><br />// Create and populate keypad buttons array with CalculatorButton values<br />private KeypadButton[] mButtons = { KeypadButton.MC, KeypadButton.MR,KeypadButton.MS, KeypadButton.M_ADD, KeypadButton.M_REMOVE,<br /> KeypadButton.BACKSPACE, KeypadButton.CE, KeypadButton.C,KeypadButton.SIGN, KeypadButton.SQRT, <br /> KeypadButton.SEVEN,KeypadButton.EIGHT, KeypadButton.NINE, KeypadButton.DIV,KeypadButton.PERCENT, <br /> KeypadButton.FOUR, KeypadButton.FIVE,KeypadButton.SIX, KeypadButton.MULTIPLY, KeypadButton.RECIPROC,<br /> KeypadButton.ONE, KeypadButton.TWO, KeypadButton.THREE,KeypadButton.MINUS, KeypadButton.DECIMAL_SEP, <br /> KeypadButton.DUMMY, KeypadButton.ZERO,KeypadButton.DUMMY,KeypadButton.PLUS, KeypadButton.CALCULATE };<br />}<br /></pre>
<p style="text-align: left;">Adapters are responsible for providing data to AdapterViews, in our case the data we will provide to our GridView is keypad button instances. To be able to create these button instances, we define an array of KeypadButton enums on Line 47-52.</p>
<p style="text-align: left;">Our KeypadAdapter provides keypad button instances to our GridView with the <strong>getView</strong> (Line 28-44) method implementation where we instantiate or revoke our keypad buttons and set their properties based on their position on the GridView.</p>
<p style="text-align: left;">Please note what Line 36 does in the code. We set KeypadButton enum instance&nbsp; as the tag of our Button and we will use that tag value during business logic implementation to identify what to do when the user presses a keypad button.</p>
<h2 style="text-align: left;">Displaying The Keypad</h2>
<p style="text-align: left;">Now, we have defined our Adapter and it is time to wire-up the GridView with our KeypadAdapter. Here is our main.java file.</p>
<pre class="brush:java;"><br />package com.pragmatouch.calculator;<br /><br />import android.app.Activity;<br />import android.os.Bundle;<br />import android.widget.AdapterView;<br />import android.widget.GridView;<br />import android.view.View;<br />import android.view.View.OnClickListener;<br /><br />public class main extends Activity {<br /> GridView mKeypadGrid;<br /> KeypadAdapter mKeypadAdapter;<br /><br />/** Called when the activity is first created. */<br />@Override<br />public void onCreate(Bundle savedInstanceState) {<br /> super.onCreate(savedInstanceState);<br /> setContentView(R.layout.main);<br /><br /> // Get reference to the keypad button GridView<br /> mKeypadGrid = (GridView) findViewById(R.id.grdButtons);<br /><br /><br /> // Create Keypad Adapter<br /> mKeypadAdapter = new KeypadAdapter(this);<br /><br /> // Set adapter of the keypad grid<br /> mKeypadGrid.setAdapter(mKeypadAdapter);<br /><br /> });<br /><br /> mKeypadGrid.setOnItemClickListener(new OnItemClickListener() {<br />     public void onItemClick(AdapterView&lt;?&gt; parent, View v,int position, long id) {<br />       // This will not help us catch button clicks!<br />     }<br /> });<br /><br /> }<br /><br />}<br /><br /></pre>
<p style="text-align: left;">Note that we create an instance of our KeypadAdapter on Line 25 and set this instance as the adapter of our GridView on Line 28. Another thing I want you to notice in the code above is the findViewById call on Line 21. As I noted in previous section, we use the value of the id attribute we have assigned to our GridView in our layout XML (main.xml).</p>
<p style="text-align: left;">When you run the TouchCalculator at this point, you will see the following UI which is almost the same as our mockup.</p>
<p><img src="/image.axd?picture=2010%2f8%2ftc1.PNG" alt="" width="195" height="263" /></p>
<p>&nbsp;</p>
<h2>Implementing The Business Logic</h2>
<p style="text-align: left;">Now it is time to implement the business logic of our calculator. We will utilize Java <a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/Stack.html" target="_blank">Stack</a> class in order to implement our calulation logic. We will have two Stack instances; the first instance will hold the user input and the second stack will hold the intermediate calculation results. We will wrap our business logic as an instance method inside our main class. Here is our ProcessKeypadInput method along with some utility methods.</p>
<pre class="brush:java;"><br />private void ProcessKeypadInput(KeypadButton keypadButton) {<br />		// Toast.makeText(this, keypadButton.getText(),<br />		// Toast.LENGTH_SHORT).show();<br />		String text = keypadButton.getText().toString();<br />		String currentInput = userInputText.getText().toString();<br /><br />		int currentInputLen = currentInput.length();<br />		String evalResult = null;<br />		double userInputValue = Double.NaN;<br /><br />		switch (keypadButton) {<br />		case BACKSPACE: // Handle backspace<br />			// If has operand skip backspace<br />			if (resetInput)<br />				return;<br /><br />			int endIndex = currentInputLen - 1;<br /><br />			// There is one character at input so reset input to 0<br />			if (endIndex &lt; 1) {<br />				userInputText.setText("0");<br />			}<br />			// Trim last character of the input text<br />			else {<br />				userInputText.setText(currentInput.subSequence(0, endIndex));<br />			}<br />			break;<br />		case SIGN: // Handle -/+ sign<br />			// input has text and is different than initial value 0<br />			if (currentInputLen &gt; 0 &amp;&amp; currentInput != "0") {<br />				// Already has (-) sign. Remove that sign<br />				if (currentInput.charAt(0) == '-') {<br />					userInputText.setText(currentInput.subSequence(1,<br />							currentInputLen));<br />				}<br />				// Prepend (-) sign<br />				else {<br />					userInputText.setText("-" + currentInput.toString());<br />				}<br />			}<br />			break;<br />		case CE: // Handle clear input<br />			userInputText.setText("0");<br />			break;<br />		case C: // Handle clear input and stack<br />			userInputText.setText("0");<br />			clearStacks();<br />			break;<br />		case DECIMAL_SEP: // Handle decimal seperator<br />			if (hasFinalResult || resetInput) {<br />				userInputText.setText("0" + mDecimalSeperator);<br />				hasFinalResult = false;<br />				resetInput = false;<br />			} else if (currentInput.contains("."))<br />				return;<br />			else<br />				userInputText.append(mDecimalSeperator);<br />			break;<br />		case DIV:<br />		case PLUS:<br />		case MINUS:<br />		case MULTIPLY:<br />			if (resetInput) {<br />				mInputStack.pop();<br />				mOperationStack.pop();<br />			} else {<br />				if (currentInput.charAt(0) == '-') {<br />					mInputStack.add("(" + currentInput + ")");<br />				} else {<br />					mInputStack.add(currentInput);<br />				}<br />				mOperationStack.add(currentInput);<br />			}<br /><br />			mInputStack.add(text);<br />			mOperationStack.add(text);<br /><br />			dumpInputStack();<br />			evalResult = evaluateResult(false);<br />			if (evalResult != null)<br />				userInputText.setText(evalResult);<br /><br />			resetInput = true;<br />			break;<br />		case CALCULATE:<br />			if (mOperationStack.size() == 0)<br />				break;<br /><br />			mOperationStack.add(currentInput);<br />			evalResult = evaluateResult(true);<br />			if (evalResult != null) {<br />				clearStacks();<br />				userInputText.setText(evalResult);<br />				resetInput = false;<br />				hasFinalResult = true;<br />			}<br />			break;<br />		case M_ADD: // Add user input value to memory buffer<br />			userInputValue = tryParseUserInput();<br />			if (Double.isNaN(userInputValue))<br />				return;<br />			if (Double.isNaN(memoryValue))<br />				memoryValue = 0;<br />			memoryValue += userInputValue;<br />			displayMemoryStat();<br /><br />			hasFinalResult = true;<br /><br />			break;<br />		case M_REMOVE: // Subtract user input value to memory buffer<br />			userInputValue = tryParseUserInput();<br />			if (Double.isNaN(userInputValue))<br />				return;<br />			if (Double.isNaN(memoryValue))<br />				memoryValue = 0;<br />			memoryValue -= userInputValue;<br />			displayMemoryStat();<br />			hasFinalResult = true;<br />			break;<br />		case MC: // Reset memory buffer to 0<br />			memoryValue = Double.NaN;<br />			displayMemoryStat();<br />			break;<br />		case MR: // Read memoryBuffer value<br />			if (Double.isNaN(memoryValue))<br />				return;<br />			userInputText.setText(doubleToString(memoryValue));<br />			displayMemoryStat();<br />			break;<br />		case MS: // Set memoryBuffer value to user input<br />			userInputValue = tryParseUserInput();<br />			if (Double.isNaN(userInputValue))<br />				return;<br />			memoryValue = userInputValue;<br />			displayMemoryStat();<br />			hasFinalResult = true;<br />			break;<br />		default:<br />			if (Character.isDigit(text.charAt(0))) {<br />				if (currentInput.equals("0") || resetInput || hasFinalResult) {<br />					userInputText.setText(text);<br />					resetInput = false;<br />					hasFinalResult = false;<br />				} else {<br />					userInputText.append(text);<br />					resetInput = false;<br />				}<br /><br />			}<br />			break;<br /><br />		}<br /><br />	}<br /><br />	private void clearStacks() {<br />		mInputStack.clear();<br />		mOperationStack.clear();<br />		mStackText.setText("");<br />	}<br /><br />	private void dumpInputStack() {<br />		Iterator&lt;String&gt; it = mInputStack.iterator();<br />		StringBuilder sb = new StringBuilder();<br /><br />		while (it.hasNext()) {<br />			CharSequence iValue = it.next();<br />			sb.append(iValue);<br /><br />		}<br /><br />		mStackText.setText(sb.toString());<br />	}<br /><br />	private String evaluateResult(boolean requestedByUser) {<br />		if ((!requestedByUser &amp;&amp; mOperationStack.size() != 4)<br />				|| (requestedByUser &amp;&amp; mOperationStack.size() != 3))<br />			return null;<br /><br />		String left = mOperationStack.get(0);<br />		String operator = mOperationStack.get(1);<br />		String right = mOperationStack.get(2);<br />		String tmp = null;<br />		if (!requestedByUser)<br />			tmp = mOperationStack.get(3);<br /><br />		double leftVal = Double.parseDouble(left.toString());<br />		double rightVal = Double.parseDouble(right.toString());<br />		double result = Double.NaN;<br /><br />		if (operator.equals(KeypadButton.DIV.getText())) {<br />			result = leftVal / rightVal;<br />		} else if (operator.equals(KeypadButton.MULTIPLY.getText())) {<br />			result = leftVal * rightVal;<br /><br />		} else if (operator.equals(KeypadButton.PLUS.getText())) {<br />			result = leftVal + rightVal;<br />		} else if (operator.equals(KeypadButton.MINUS.getText())) {<br />			result = leftVal - rightVal;<br /><br />		}<br /><br />		String resultStr = doubleToString(result);<br />		if (resultStr == null)<br />			return null;<br /><br />		mOperationStack.clear();<br />		if (!requestedByUser) {<br />			mOperationStack.add(resultStr);<br />			mOperationStack.add(tmp);<br />		}<br /><br />		return resultStr;<br />	}<br /><br />	private String doubleToString(double value) {<br />		if (Double.isNaN(value))<br />			return null;<br /><br />		long longVal = (long) value;<br />		if (longVal == value)<br />			return Long.toString(longVal);<br />		else<br />			return Double.toString(value);<br /><br />	}<br /><br />	private double tryParseUserInput() {<br />		String inputStr = userInputText.getText().toString();<br />		double result = Double.NaN;<br />		try {<br />			result = Double.parseDouble(inputStr);<br /><br />		} catch (NumberFormatException nfe) {}<br />		return result;<br /><br />	}<br /><br />	private void displayMemoryStat() {<br />		if (Double.isNaN(memoryValue)) {<br />			memoryStatText.setText("");<br />		} else {<br />			memoryStatText.setText("M = " + doubleToString(memoryValue));<br />		}<br />	}</pre>
<p style="text-align: left;">ProcessKeypadInput method is called each time user presses a keypad button and we decide what to do with a swtich/case code block. We also have some helper methods</p>
<ul>
<li>clearStacks, is used to clear our stacks and the user input TextView</li>
<li>dumpInputStack, is used to dump the input stack as a single line string to the TextView represented as Area #1 in our mockup</li>
<li>evaluateResult, is called when user presses an artihmetic operation keypad button or the (=) keypad button. Inside this method we try to calculate a result by popping values from our operation stack and we push the result as the first item to the operation stack if we were able to calculate a result</li>
<li>doubleToString, utility method which is used to convert a double value to String</li>
<li>tryParseUserInput, utility method where we try to parse the user input, represented as Area #2 in our mockup, as a valid double value </li>
<li>displayMemoryStat, utility method used to dump the memory buffer status and value to the Area #3 in our mockup</li>
</ul>
<h2>The Right Place To Call ProcessKeypadInput Method</h2>
<p>In "Displaying The Keypad" section please take a look at the comment placed on Line 34. If you read the <a href="http://developer.android.com/resources/tutorials/views/hello-gridview.html" target="_blank">GridView Sample&nbsp;</a> in Android Developers site, you might think that this line is the right place to put the ProcessKeypadInput method call since the user will click on the keypad buttons which are in turn items of our GridView that in turn will trigger the OnItemClick event. This assumption is absolutely wrong in our case. If you put&nbsp; the call to ProcessKeypadInput method&nbsp; on that line and run your application OnItemClick of our GridView will not be fired even though a button is pressed. The reason for this misconception is this : Since Button views placed in the cells of the GridView are clickable, when user clicks over a button the Button view handles that click and the action is not propagated to the GridView.</p>
<p>Solution to this problem is pretty straight forward; we have to set OnClickListener of our keypad Button views and we will do that in our KeypadAdapter class. Below is the modified version of our&nbsp; KeypadAdapter class.</p>
<pre class="brush:java;"><br /><br />package com.pragmatouch.calculator;<br /><br />import android.widget.*;<br />import android.content.*;<br />import android.view.*;<br />import android.view.View.OnClickListener;<br /><br />public class KeypadAdapter extends BaseAdapter {<br />	private Context mContext;<br /><br />	// Declare button click listener variable<br />	private OnClickListener mOnButtonClick;<br /><br />	public KeypadAdapter(Context c) {<br />		mContext = c;<br />	}<br /><br />	// Method to set button click listener variable<br />	public void setOnButtonClickListener(OnClickListener listener) {<br />		mOnButtonClick = listener;<br />	}<br /><br />	public int getCount() {<br />		return mButtons.length;<br />	}<br /><br />	public Object getItem(int position) {<br />		return mButtons[position];<br />	}<br /><br />	public long getItemId(int position) {<br />		return 0;<br />	}<br /><br />	// create a new ButtonView for each item referenced by the Adapter<br />	public View getView(int position, View convertView, ViewGroup parent) {<br />		Button btn;<br />		if (convertView == null) { // if it's not recycled, initialize some<br />									// attributes<br /><br />			btn = new Button(mContext);<br />			KeypadButton keypadButton = mButtons[position];<br />			if (keypadButton != KeypadButton.DUMMY)<br />               btn.setOnClickListener(mOnButtonClick);<br /><br />			// Set CalculatorButton enumeration as tag of the button so that we<br />			// will use this information from our main view to identify what to<br />			// do<br />			btn.setTag(keypadButton);<br />		} else {<br />			btn = (Button) convertView;<br />		}<br /><br />		btn.setText(mButtons[position].getText());<br />		return btn;<br />	}<br /><br />	// Create and populate keypad buttons array with CalculatorButton enum<br />	// values<br />	private KeypadButton[] mButtons = { KeypadButton.MC, KeypadButton.MR,<br />	  KeypadButton.MS, KeypadButton.M_ADD, KeypadButton.M_REMOVE,<br />	  KeypadButton.BACKSPACE, KeypadButton.CE, KeypadButton.C,<br />	  KeypadButton.SIGN, KeypadButton.SQRT, KeypadButton.SEVEN,<br />	  KeypadButton.EIGHT, KeypadButton.NINE, KeypadButton.DIV,<br />	  KeypadButton.PERCENT, KeypadButton.FOUR, KeypadButton.FIVE,<br />	  KeypadButton.SIX, KeypadButton.MULTIPLY, KeypadButton.RECIPROC,<br />	  KeypadButton.ONE, KeypadButton.TWO, KeypadButton.THREE,<br />	  KeypadButton.MINUS, KeypadButton.DECIMAL_SEP, KeypadButton.DUMMY,<br />	  KeypadButton.ZERO, KeypadButton.DUMMY, KeypadButton.PLUS,<br />	KeypadButton.CALCULATE };<br /><br />}</pre>
<p>We declared mOnButtonClick field on Line 12 and defined a setter method for this field on Line 19-21. Then we set OnClickListener of our Button views to mOnButtonClick value on Line 43-44.</p>
<p>In order to catch button clicks and call ProcessKeypadInput, we also have to modify our main class.</p>
<pre class="brush:java;">package com.pragmatouch.calculator;<br /><br />import android.app.Activity;<br />import android.os.Bundle;<br />import android.widget.AdapterView;<br />import android.widget.GridView;<br />import android.view.View;<br />import android.view.View.OnClickListener;<br /><br />public class main extends Activity {<br /> GridView mKeypadGrid;<br /> KeypadAdapter mKeypadAdapter;<br /><br />/** Called when the activity is first created. */<br />@Override<br />public void onCreate(Bundle savedInstanceState) {<br /> super.onCreate(savedInstanceState);<br /> setContentView(R.layout.main);<br /><br /> // Get reference to the keypad button GridView<br /> mKeypadGrid = (GridView) findViewById(R.id.grdButtons);<br /><br /><br /> // Create Keypad Adapter<br /> mKeypadAdapter = new KeypadAdapter(this);<br /><br /> // Set adapter of the keypad grid<br /> mKeypadGrid.setAdapter(mKeypadAdapter);<br /><br /> // Set button click listener of the keypad adapter<br /> mKeypadAdapter.setOnButtonClickListener(new OnClickListener() {<br /> @Override<br /> public void onClick(View v) {<br />   Button btn = (Button) v;<br />   // Get the KeypadButton value which is used to identify the<br />   // keypad button from the Button's tag<br />   KeypadButton keypadButton = (KeypadButton) btn.getTag();<br />   <br />   // Process keypad button<br />   ProcessKeypadInput(keypadButton);<br />  }});<br /> });<br /><br /> mKeypadGrid.setOnItemClickListener(new OnItemClickListener() {<br />     public void onItemClick(AdapterView&lt;?&gt; parent, View v,int position, long id) {<br />       // This will not help us catch button clicks!<br />     }<br /> });<br /><br /> }<br /><br />}<br />
</pre>
<p>We set OnButtonClickListener of our KeypadAdapter class on Line 31-42.</p>
<h2>Are we done yet?<br /></h2>
<p>We have a fully functional (actually I left implementaton of SQRT, 1/x and % to you as an excercise) standard calculator but there is always room for improvement and visual styling. In this last section I will try to show you a simple sample for styling our keypad buttons and the TextViews we have used in our UI. For more information about Using Styles And Themes please visit this <a href="http://developer.android.com/guide/topics/ui/themes.html" target="_blank">link</a>.</p>
<h3>Applying Style To Our Keypad</h3>
<p>Android has lots of different resource types and it is possible to style your Android application's UI at different levels by utilizing these resources. As a simple example, we will use Drawable resource type (to be more specific <a href="http://developer.android.com/guide/topics/resources/drawable-resource.html#StateList" target="_blank">State List</a> drawable resource type) for styling. You can check out this <a href="http://developer.android.com/guide/topics/resources/available-resources.html" target="_blank">link</a> for more resource types though.</p>
<p>First of all we have to define a State List drawable as an XML file under <strong>res/drawable</strong>. If you installed the latest Android SDK you will see <strong>drawable-hdpi</strong>, <strong>drawable-ldpi</strong> under res folder but there is no <strong>drawable</strong> folder. You can safely create a <strong>drawable</strong> folder if you do not already have one. After ensuring that <strong>drawable</strong> folder exists, add an XML file with name keypadclear1.xml. Inside keypadclear1.xml you will have the following markup code which defines a style for Button views.</p>
<pre class="brush:java;"><br />&lt;?xml version="1.0" encoding="utf-8"?&gt;<br />&lt;selector<br />    xmlns:android="http://schemas.android.com/apk/res/android"&gt;<br />    &lt;item android:state_pressed="true" &gt;<br />        &lt;shape&gt;<br />            &lt;gradient<br />                android:startColor="#ff8c00"<br />                android:endColor="#FFFFFF"<br />                android:angle="270" /&gt;<br />            &lt;stroke<br />                android:width="2dp"<br />                android:color="#dcdcdc" /&gt;<br />            &lt;corners<br />                android:radius="2dp" /&gt;<br />            &lt;padding<br />                android:left="10dp"<br />                android:top="10dp"<br />                android:right="10dp"<br />                android:bottom="10dp" /&gt;<br />        &lt;/shape&gt;<br />    &lt;/item&gt;<br /><br />    &lt;item android:state_focused="true" &gt;<br />        &lt;shape&gt;<br />            &lt;gradient<br />                android:startColor="#ffc2b7"<br />                android:endColor="#ffc2b7"<br />                android:angle="270" /&gt;<br />            &lt;stroke<br />                android:width="2dp"<br />                android:color="#dcdcdc" /&gt;<br />            &lt;corners<br />                android:radius="2dp" /&gt;<br />            &lt;padding<br />                android:left="10dp"<br />                android:top="10dp"<br />                android:right="10dp"<br />                android:bottom="10dp" /&gt;<br />        &lt;/shape&gt;<br />    &lt;/item&gt;<br /><br />    &lt;item&gt;        <br />        &lt;shape&gt;<br />            &lt;gradient<br />                android:startColor="#ff9d77"<br />                android:endColor="#ff9d77"<br />                android:angle="270" /&gt;<br />            &lt;stroke<br />                android:width="2dp"<br />                android:color="#fad3cf" /&gt;<br />            &lt;corners<br />                android:radius="2dp" /&gt;<br />            &lt;padding<br />                android:left="10dp"<br />                android:top="10dp"<br />                android:right="10dp"<br />                android:bottom="10dp" /&gt;<br />        &lt;/shape&gt;<br />    &lt;/item&gt;<br />&lt;/selector&gt;<br />
</pre>
<p>keypadclear1.xml contains seperate style definitions for each of the three possible states of a Button view. Now that we have our State List drawable resource ready, we have to write some code to make use of this resource. We will set the background of keypad buttons of KeypadButtonCategory.CLEAR to be styled according to the definitions of keypadclear1.xml. We will modify getView method of our KeypadAdapter class slightly</p>
<pre class="brush:java;"><br />	// create a new ButtonView for each item referenced by the Adapter<br />	public View getView(int position, View convertView, ViewGroup parent) {<br />		Button btn;<br />		if (convertView == null) { // if it's not recycled, initialize some attributes<br /><br />			btn = new Button(mContext);<br />			KeypadButton keypadButton = mButtons[position];<br />			<br />			if (keypadButton != KeypadButton.DUMMY)<br />               btn.setOnClickListener(mOnButtonClick);<br />            <br />			if(keypadButton != KeypadButton.CLEAR)<br />			   btn.setBackgroundResource(R.drawable.keypadclear1);<br />			<br />			// Set CalculatorButton enumeration as tag of the button so that we<br />			// will use this information from our main view to identify what to do<br />			btn.setTag(keypadButton);<br />		} else {<br />			btn = (Button) convertView;<br />		}<br /><br />		btn.setText(mButtons[position].getText());<br />		return btn;<br />	}</pre>
<p>On Line 13, we set the background resource of our Button views if they are categorized as KeypadButtonCategory.CLEAR and that is all, we have pinky rounded buttons&nbsp; sketched as Area #9 in our mockup.</p>
<h2>Accomplishment</h2>
<p>We got familiar with Android application development and evaluate different aspects of an Android application's UI. We developed a styled calculator which looks like the image atatched below</p>
<p><img src="/image.axd?picture=2010%2f8%2fTouchCalc.PNG" alt="" width="210" height="316" /></p>
<h2>Is There Room For Improvement In TouchCalculator?</h2>
<p>Yes. There is always room for improvement and I intentionally left some business logic implementation to you. Here is the list of possible improvements</p>
<ul>
<li>Implement SQRT</li>
<li>Implement 1/x (reciproc)</li>
<li>Implement % (percent)</li>
<li>Handle division by zero cases properly</li>
<li>Implement different styles and provide "Switch Theme" <a href="http://developer.android.com/guide/topics/ui/dialogs.html" target="_blank">dialog</a> to the user </li>
</ul>
<p>&nbsp;</p>
<h2>Other Notes<br /></h2>
<p><strong>How to fix </strong><strong>Eclipse SDK 3.6 </strong><strong>null pointer exception appearing when you try to edit res/values/strings.xml resource?</strong></p>
<p>Open  res\values\strings.xml with Text Editor and replace &lt;resources&gt;  with &lt;resources  xmlns:android="http://schemas.android.com/apk/res/android"&gt;</p>
<p>&nbsp;</p>